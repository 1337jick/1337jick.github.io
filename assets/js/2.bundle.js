(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{17:function(e,n,i){"use strict";i.r(n);var o=i(67),t=i(71),a=i(70),r=i(0),s=i(73),d=i(72),c=i(75),l=i(74),u=i(76);n.default=function(e){var n,i,h,m=e.querySelector("canvas.js-scene"),g={width:window.innerWidth,height:window.innerHeight},f={exposure:1.09,bloomStrength:.45,bloomThreshold:0,bloomRadius:.73},p={x:0,y:0},x=new o.eb,w=new o.W(75,g.width/g.height,.01,1e3),v=new o.wb({canvas:m}),M=new t.a(w,m),C=0,z=new d.a;z.setDecoderPath("/assets/draco/");var b=new s.a;b.setDRACOLoader(z);var y,P,V=function e(){M.update(),n.render(x,w),C+=.05,window.requestAnimationFrame(e),h&&h.material.userData&&(h.material.userData.shader.uniforms.uTime.value=C)};window.addEventListener("resize",(function(){g.width=window.innerWidth,g.height=window.innerHeight,w.aspect=g.width/g.height,w.updateProjectionMatrix(),v.setSize(g.width,g.height),v.setPixelRatio(Math.min(window.devicePixelRatio,2))})),window.addEventListener("mousemove",(function(e){p.x=e.clientX/g.width-.5,p.y=-(e.clientY/g.height-.5)})),w.position.set(.57,1.07,.94),w.zoom=16,w.updateProjectionMatrix(),x.add(w),M.enableDamping=!0,v.toneMapping=o.a,v.toneMappingExposure=f.exposure,v.setSize(g.width,g.height),v.setPixelRatio(Math.min(window.devicePixelRatio,2)),function(){var e=new o.V(v);e.compileEquirectangularShader();var n=(new o.ob).load("/assets/models/env.jpg",(function(t){n=e.fromEquirectangular(t).texture,e.dispose(),b.load("/assets/models/panama_lowres3.glb",(function(e){x.add(e.scene),(h=e.scene.children[0]).scale.set(1,1,1),h.rotation.set(0,-.5*Math.PI,0),h.position.set(0,-.8,.03),h.geometry.center(),h.material=new o.N({metalness:1,roughness:.28}),h.material.envMap=n,h.material.onBeforeCompile=function(e){console.log("before compile happen"),e.uniforms.uTime={value:0},e.fragmentShader="\n                    uniform float uTime;\n\n                    mat4 rotationMatrix(vec3 axis, float angle) {\n                        axis = normalize(axis);\n                        float s = sin(angle);\n                        float c = cos(angle);\n                        float oc = 1.0 - c;\n                        \n                        return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                                    0.0,                                0.0,                                0.0,                                1.0);\n                    }\n                    \n                    vec3 rotate(vec3 v, vec3 axis, float angle) {\n                        mat4 m = rotationMatrix(axis, angle);\n                        return (m * vec4(v, 1.0)).xyz;\n                    }\n\n                    "+e.fragmentShader,e.fragmentShader=e.fragmentShader.replace("#include <envmap_physical_pars_fragment>","#if defined( USE_ENVMAP )\n                            vec3 getIBLIrradiance( const in vec3 normal ) {\n                                #if defined( ENVMAP_TYPE_CUBE_UV )\n                                    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n                                    vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n                                    return PI * envMapColor.rgb * envMapIntensity;\n                                #else\n                                    return vec3( 0.0 );\n                                #endif\n                            }\n                            vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n                                #if defined( ENVMAP_TYPE_CUBE_UV )\n                                    vec3 reflectVec = reflect( - viewDir, normal );\n                                    // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n                                    reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n                                    reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n                                    reflectVec = rotate(reflectVec, vec3(1.0, 0.0, 0.0), uTime * 0.05);\n                                    vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n                                    return envMapColor.rgb * envMapIntensity;\n                                #else\n                                    return vec3( 0.0 );\n                                #endif\n                            }\n                        #endif\n                    "),h.material.userData.shader=e,function(){var e,n=r.a.timeline(),i=((e=r.a.timeline()).to(w.position,{scrollTrigger:{trigger:".js-header",start:function(){return"top top"},end:function(){return"+="+2*window.innerHeight},scrub:!0,invalidateOnRefresh:!0},x:-1,y:0,z:0}),e.to(w,{scrollTrigger:{trigger:".js-header",start:function(){return"top+=1000 top"},end:function(){return"+=1000"},scrub:!0,invalidateOnRefresh:!0},zoom:5,onUpdate:function(){w.updateProjectionMatrix()}}),e.to(h.position,{scrollTrigger:{trigger:".js-header",start:function(){return"top top-="+(2*window.innerHeight+100)},end:function(){return"+="+window.innerHeight},scrub:!0,invalidateOnRefresh:!0},y:-.4}),e);n.add(i)}()},i.add(h.position,"x",-2,2,.01).onChange((function(e){h.position.x=e})).name("Model Position X"),i.add(h.position,"y",-2,2,.01).onChange((function(e){h.position.y=e})).name("Model Position Y"),i.add(h.position,"z",-2,2,.01).onChange((function(e){h.position.z=e})).name("Model Position Z"),i.add(h.rotation,"x",-2,2,.01).onChange((function(e){h.rotation.x=e})).name("Model rotation X"),i.add(h.rotation,"y",-2,2,.01).onChange((function(e){h.rotation.y=e})).name("Model rotation Y"),i.add(h.rotation,"z",-2,2,.01).onChange((function(e){h.rotation.z=e})).name("Model rotation Z"),i.add(h.material,"metalness",-2,2,.01).onChange((function(e){h.material.metalness=e})).name("Model metalness")}))}))}(),(i=new a.a).add(f,"exposure",0,2,.01).onChange((function(){v.toneMappingExposure=f.exposure})),i.add(w.position,"x",-5,5,.01).onChange((function(e){w.position.x=e,M.update()})).name("Camera Position X"),i.add(w.position,"y",-5,5,.01).onChange((function(e){w.position.y=e,M.update()})).name("Camera Position Y"),i.add(w.position,"z",-5,5,.01).onChange((function(e){w.position.z=e,M.update()})).name("Camera Position Z"),i.add(w,"zoom",-20,20,.01).onChange((function(e){w.zoom=e,w.updateProjectionMatrix()})).name("Camera Zoom"),y=new l.a(x,w),(P=new u.a(new o.sb(window.innerWidth,window.innerHeight),1.5,.4,.85)).threshold=f.bloomThreshold,P.strength=f.bloomStrength,P.radius=f.bloomRadius,(n=new c.a(v)).addPass(y),n.addPass(P),i.add(P,"threshold",0,1,.01).onChange((function(e){P.threshold=e})),i.add(P,"strength",0,5,.01).onChange((function(e){P.strength=e})),i.add(P,"radius",0,1.5,.01).onChange((function(e){P.radius=e})),V()}}}]);